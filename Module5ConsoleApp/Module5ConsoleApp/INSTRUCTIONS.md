# Інструкції для викладача

## Структура матеріалів

### 1. README.md
Містить повний теоретичний матеріал по всіх темах модуля:
- Перевантаження операторів (унарні, бінарні, відношень, логічні, true/false, перетворення)
- Індексатори (одновимірні, багатовимірні, перевантаження)
- Властивості (get, set, init, автоматичні властивості, ініціалізація)

### 2. Файли з прикладами коду

#### OperatorOverloadingExamples.cs
Містить 6 практичних прикладів:
- `Vector2D` - перевантаження унарних операторів (-, +)
- `ComplexNumber` - перевантаження бінарних операторів (+, -, *, /)
- `Fraction` - перевантаження операторів відношень (==, !=, <, >, <=, >=)
- `BooleanWrapper` - перевантаження логічних операторів (&, |, ^, !, true, false)
- `Temperature` - перевантаження операторів перетворення (implicit, explicit)
- `Counter` - перевантаження операторів інкремента/декремента (++, --)

#### IndexerExamples.cs
Містить 6 практичних прикладів:
- `SimpleArray` - простий одновимірний індексатор
- `DictionaryWrapper` - індексатор з рядковим ключем
- `Matrix` - багатовимірний індексатор
- `SmartCollection` - перевантаження індексаторів
- `ReadOnlyCollection` - індексатор тільки для читання
- `StudentGrades` - складний індексатор з валідацією

#### PropertyExamples.cs
Містить 10 практичних прикладів:
- `PersonFullSyntax` - повний синтаксис властивості
- `PersonAutoProperty` - автоматичні властивості
- `PersonAccessModifiers` - властивості з різними модифікаторами доступу
- `PersonReadOnly` - властивості тільки для читання
- `PersonInit` - властивості з init аксесором
- `Rectangle` - обчислювані властивості
- `PersonInitialized` - ініціалізація автоматичних властивостей
- `BankAccount` - властивості з логікою в get/set
- `Product` - властивості різних типів
- `Student` - властивості з init та валідацією

### 3. Program.cs
Головний файл з демонстрацією всіх прикладів. Містить 20 демонстраційних блоків, які показують роботу всіх концепцій.

## Як використовувати

### Запуск проекту
```bash
dotnet run
```

Або в Visual Studio/VS Code просто натисніть F5.

### План викладання

1. **Теоретична частина (30-40 хвилин)**
   - Використовуйте README.md для пояснення концепцій
   - Поясніть кожну тему з прикладами з файлів

2. **Практична демонстрація (40-50 хвилин)**
   - Запустіть Program.cs
   - Поясніть кожен приклад по черзі
   - Покажіть, як працює код

3. **Практичні вправи (30-40 хвилин)**
   - Попросіть студентів створити власні приклади
   - Наприклад:
     - Створити клас Money з перевантаженням операторів +, -, *, /
     - Створити клас PhoneBook з індексатором по імені
     - Створити клас Car з властивостями та валідацією

### Важливі моменти для пояснення

#### Перевантаження операторів:
- Наголосіть на тому, що оператори повинні бути інтуїтивними
- Завжди перевантажуйте пари операторів разом (== і !=, < і >)
- При перевантаженні == обов'язково перевизначайте Equals() і GetHashCode()

#### Індексатори:
- Індексатор - це як властивість з параметрами
- Можна мати кілька індексаторів з різними типами параметрів
- Завжди додавайте валідацію індексів

#### Властивості:
- Властивості краще за публічні поля (інкапсуляція)
- Автоматичні властивості - це скорочений синтаксис
- init дозволяє встановити значення тільки при створенні об'єкта
- Обчислювані властивості не зберігають значення, а обчислюють його

### Можливі питання студентів

**Q: Чи можна створити новий оператор?**
A: Ні, можна тільки перевантажувати існуючі.

**Q: Чи обов'язково перевантажувати == і != разом?**
A: Так, це рекомендовано для коректної роботи.

**Q: Чим індексатор відрізняється від методу?**
A: Індексатор дозволяє використовувати синтаксис масиву: `obj[0]` замість `obj.GetValue(0)`.

**Q: Коли використовувати властивості, а коли методи?**
A: Властивості для доступу до даних, методи для виконання дій.

**Q: Що таке backing field?**
A: Приватне поле, яке зберігає значення властивості.

## Додаткові матеріали

Можна розширити матеріали:
- Додати приклади з реальних проектів
- Створити вправи для самостійної роботи
- Додати тести для перевірки знань

## Детальні пояснення прикладів з очікуваним виводом

### РОЗДІЛ 1: Перевантаження операторів

#### Приклад 1: Перевантаження унарних операторів (Vector2D)
**Клас:** `Vector2D`  
**Що демонструє:** Перевантаження унарних операторів `-` (мінус) та `+` (плюс)

**Код:**
```csharp
Vector2D v1 = new Vector2D(3, 4);
Console.WriteLine($"Вектор v1: {v1}");
Console.WriteLine($"Унарний мінус (-v1): {-v1}");
Console.WriteLine($"Унарний плюс (+v1): {+v1}");
```

**Очікуваний вивід:**
```
1. ПЕРЕВАНТАЖЕННЯ УНАРНИХ ОПЕРАТОРІВ
=====================================
Вектор v1: (3, 4)
Унарний мінус (-v1): (-3, -4)
Унарний плюс (+v1): (3, 4)
```

**Пояснення:**
- Створюємо вектор з координатами (3, 4)
- Унарний мінус `-v1` інвертує знаки координат: (-3, -4)
- Унарний плюс `+v1` залишає вектор без змін: (3, 4)
- Оператори визначені як статичні методи з ключовим словом `operator`

---

#### Приклад 2: Перевантаження бінарних операторів (ComplexNumber)
**Клас:** `ComplexNumber`  
**Що демонструє:** Перевантаження бінарних операторів `+`, `-`, `*`, `/` для комплексних чисел

**Код:**
```csharp
ComplexNumber c1 = new ComplexNumber(2, 3);
ComplexNumber c2 = new ComplexNumber(1, 4);
Console.WriteLine($"c1 + c2 = {c1 + c2}");
Console.WriteLine($"c1 - c2 = {c1 - c2}");
Console.WriteLine($"c1 * c2 = {c1 * c2}");
Console.WriteLine($"c1 / c2 = {c1 / c2}");
```

**Очікуваний вивід:**
```
2. ПЕРЕВАНТАЖЕННЯ БІНАРНИХ ОПЕРАТОРІВ
=====================================
Комплексне число c1: 2 + 3i
Комплексне число c2: 1 + 4i
c1 + c2 = 3 + 7i
c1 - c2 = 1 - 1i
c1 * c2 = -10 + 11i
c1 / c2 = 0.823529411764706 + 0.294117647058824i
```

**Пояснення:**
- `c1 + c2`: додаємо дійсні та уявні частини окремо: (2+1) + (3+4)i = 3 + 7i
- `c1 - c2`: віднімаємо: (2-1) + (3-4)i = 1 - 1i
- `c1 * c2`: множення за формулою (a+bi)(c+di) = (ac-bd) + (ad+bc)i
- `c1 / c2`: ділення за формулою комплексного ділення

---

#### Приклад 3: Перевантаження операторів відношень (Fraction)
**Клас:** `Fraction`  
**Що демонструє:** Перевантаження операторів `==`, `!=`, `<`, `>`, `<=`, `>=` для дробів

**Код:**
```csharp
Fraction f1 = new Fraction(1, 2);
Fraction f2 = new Fraction(2, 4);
Fraction f3 = new Fraction(3, 4);
Console.WriteLine($"f1 == f2: {f1 == f2}"); // True (1/2 == 2/4)
Console.WriteLine($"f1 < f3: {f1 < f3}");   // True (1/2 < 3/4)
```

**Очікуваний вивід:**
```
3. ПЕРЕВАНТАЖЕННЯ ОПЕРАТОРІВ ВІДНОШЕНЬ
=====================================
Дріб f1: 1/2
Дріб f2: 1/2
Дріб f3: 3/4
f1 == f2: True
f1 != f2: False
f1 < f3: True
f1 > f3: False
f1 <= f2: True
f1 >= f3: False
```

**Пояснення:**
- Дроби автоматично спрощуються (2/4 стає 1/2)
- `f1 == f2` повертає `True`, бо 1/2 = 2/4 (після спрощення)
- `f1 < f3` повертає `True`, бо 1/2 < 3/4
- **Важливо:** Перевантажуємо пари операторів разом (== і !=, < і >)

---

#### Приклад 4: Перевантаження логічних операторів (BooleanWrapper)
**Клас:** `BooleanWrapper`  
**Що демонструє:** Перевантаження логічних операторів `&`, `|`, `^`, `!`, `true`, `false`

**Код:**
```csharp
BooleanWrapper b1 = new BooleanWrapper(true);
BooleanWrapper b2 = new BooleanWrapper(false);
Console.WriteLine($"b1 & b2 = {b1 & b2}");  // False
Console.WriteLine($"b1 | b2 = {b1 | b2}");  // True
if (b1) Console.WriteLine("b1 is true");
```

**Очікуваний вивід:**
```
4. ПЕРЕВАНТАЖЕННЯ ЛОГІЧНИХ ОПЕРАТОРІВ
=====================================
b1 = True, b2 = False
b1 & b2 = False
b1 | b2 = True
b1 ^ b2 = True
!b1 = False
b1 is true
b2 is false
```

**Пояснення:**
- `b1 & b2`: логічне І (True & False = False)
- `b1 | b2`: логічне АБО (True | False = True)
- `b1 ^ b2`: виключне АБО (True ^ False = True)
- `!b1`: заперечення (not True = False)
- `if (b1)` працює завдяки операторам `true` і `false`

---

#### Приклад 5: Перевантаження операторів перетворення (Temperature)
**Клас:** `Temperature`  
**Що демонструє:** Неявне (implicit) та явне (explicit) перетворення типів

**Код:**
```csharp
Temperature t1 = 25.0; // Неявне перетворення
double celsius = (double)t1; // Явне перетворення
string tempStr = t1; // Неявне перетворення в string
```

**Очікуваний вивід:**
```
5. ПЕРЕВАНТАЖЕННЯ ОПЕРАТОРІВ ПЕРЕТВОРЕННЯ
=====================================
Неявне перетворення: Temperature t1 = 25.0; -> 25°C
Явне перетворення: double celsius = (double)t1; -> 25
Неявне перетворення в string: string tempStr = t1; -> 25°C
```

**Пояснення:**
- **Неявне перетворення** (`implicit`): `Temperature t1 = 25.0;` - не потрібно вказувати тип
- **Явне перетворення** (`explicit`): `(double)t1` - потрібно вказати тип явно
- Неявне перетворення безпечніше, бо вимагає свідомого рішення

---

#### Приклад 6: Перевантаження оператора інкремента (Counter)
**Клас:** `Counter`  
**Що демонструє:** Перевантаження операторів `++` (інкремент) та `--` (декремент)

**Код:**
```csharp
Counter counter = new Counter(5);
Console.WriteLine($"Префіксний ++counter: {++counter}");
Console.WriteLine($"Постфіксний counter++: {counter++}");
```

**Очікуваний вивід:**
```
6. ПЕРЕВАНТАЖЕННЯ ОПЕРАТОРА ІНКРЕМЕНТА
=====================================
Початкове значення: 5
Префіксний ++counter: 6
Після інкремента: 6
Постфіксний counter++: 6
Після інкремента: 7
Декремент --counter: 6
```

**Пояснення:**
- **Префіксний** `++counter`: спочатку збільшує, потім повертає значення (6)
- **Постфіксний** `counter++`: спочатку повертає значення (6), потім збільшує до 7
- Обидва використовують той самий оператор `++`, різниця в порядку виконання

---

### РОЗДІЛ 2: Індексатори

#### Приклад 7: Простий одновимірний індексатор (SimpleArray)
**Клас:** `SimpleArray`  
**Що демонструє:** Базовий індексатор з числовим індексом

**Код:**
```csharp
SimpleArray arr = new SimpleArray(5);
arr[0] = 10;
arr[1] = 20;
Console.WriteLine($"arr[0] = {arr[0]}");
```

**Очікуваний вивід:**
```
7. ПРОСТИЙ ОДНОВИМІРНИЙ ІНДЕКСАТОР
=====================================
arr[0] = 10
arr[1] = 20
arr[2] = 30
```

**Пояснення:**
- Індексатор дозволяє використовувати синтаксис масиву `arr[0]`
- `get` аксесор повертає значення з валідацією індексу
- `set` аксесор встановлює значення з валідацією
- При виході за межі викидається `IndexOutOfRangeException`

---

#### Приклад 8: Індексатор з рядковим ключем (DictionaryWrapper)
**Клас:** `DictionaryWrapper`  
**Що демонструє:** Індексатор з рядковим параметром (як словник)

**Код:**
```csharp
DictionaryWrapper dict = new DictionaryWrapper();
dict["name"] = "Іван";
dict["age"] = "25";
Console.WriteLine($"dict[\"name\"] = {dict["name"]}");
```

**Очікуваний вивід:**
```
8. ІНДЕКСАТОР З РЯДКОВИМ КЛЮЧЕМ
=====================================
dict["name"] = Іван
dict["age"] = 25
dict["city"] = Київ
```

**Пояснення:**
- Індексатор приймає `string` замість `int`
- Дозволяє звертатися до даних як до словника: `dict["key"]`
- Якщо ключ не знайдено, викидається `KeyNotFoundException`

---

#### Приклад 9: Багатовимірний індексатор (Matrix)
**Клас:** `Matrix`  
**Що демонструє:** Індексатор з двома параметрами для матриці

**Код:**
```csharp
Matrix matrix = new Matrix(3, 3);
matrix[0, 0] = 1;
matrix[0, 1] = 2;
Console.WriteLine($"{matrix[0, 0]} {matrix[0, 1]}");
```

**Очікуваний вивід:**
```
9. БАГАТОВИМІРНИЙ ІНДЕКСАТОР
=====================================
Матриця 3x3:
1 2 3 
4 5 6 
```

**Пояснення:**
- Індексатор приймає два параметри: `matrix[row, col]`
- Валідація обох індексів окремо
- Зручний доступ до двовимірних структур даних

---

#### Приклад 10: Перевантаження індексаторів (SmartCollection)
**Клас:** `SmartCollection`  
**Що демонструє:** Кілька індексаторів з різними типами параметрів

**Код:**
```csharp
SmartCollection collection = new SmartCollection();
collection.Add("Перший");
collection.Add("третій", "Третій");
Console.WriteLine($"collection[0] = {collection[0]}");
Console.WriteLine($"collection[\"третій\"] = {collection["третій"]}");
```

**Очікуваний вивід:**
```
10. ПЕРЕВАНТАЖЕННЯ ІНДЕКСАТОРІВ
=====================================
collection[0] = Перший
collection[1] = Другий
collection["третій"] = Третій
```

**Пояснення:**
- Можна мати два індексатори: `this[int]` та `this[string]`
- Доступ по числовому індексу: `collection[0]`
- Доступ по рядковому ключу: `collection["третій"]`
- Компілятор вибирає правильний індексатор за типом параметра

---

#### Приклад 11: Індексатор тільки для читання (ReadOnlyCollection)
**Клас:** `ReadOnlyCollection`  
**Що демонструє:** Індексатор без `set` аксесора

**Код:**
```csharp
ReadOnlyCollection readOnly = new ReadOnlyCollection("А", "Б", "В", "Г");
Console.WriteLine($"readOnly[0] = {readOnly[0]}");
// readOnly[0] = "X"; // Помилка - немає set
```

**Очікуваний вивід:**
```
11. ІНДЕКСАТОР ТІЛЬКИ ДЛЯ ЧИТАННЯ
=====================================
readOnly[0] = А
readOnly[2] = В
```

**Пояснення:**
- Індексатор має тільки `get`, немає `set`
- Можна тільки читати значення, не можна змінювати
- Корисно для незмінних колекцій

---

#### Приклад 12: Складний індексатор (StudentGrades)
**Клас:** `StudentGrades`  
**Що демонструє:** Індексатор з двома рядковими параметрами та валідацією

**Код:**
```csharp
StudentGrades grades = new StudentGrades();
grades["Іван", "Математика"] = 95;
Console.WriteLine($"Оцінка Івана з Математики: {grades["Іван", "Математика"]}");
```

**Очікуваний вивід:**
```
12. СКЛАДНИЙ ІНДЕКСАТОР (СТУДЕНТИ ТА ОЦІНКИ)
=====================================
Оцінка Івана з Математики: 95
Оцінка Івана з Фізики: 88
Оцінка Марії з Математики: 92
```

**Пояснення:**
- Індексатор з двома рядковими параметрами: `grades[student, subject]`
- Валідація оцінки (0-100) в `set` аксесорі
- Зручний доступ до складних структур даних

---

### РОЗДІЛ 3: Властивості

#### Приклад 13: Повний синтаксис властивості (PersonFullSyntax)
**Клас:** `PersonFullSyntax`  
**Що демонструє:** Властивість з явним backing field та валідацією

**Код:**
```csharp
PersonFullSyntax person1 = new PersonFullSyntax();
person1.Name = "Олександр";
person1.Age = 30;
Console.WriteLine($"Ім'я: {person1.Name}, Вік: {person1.Age}");
```

**Очікуваний вивід:**
```
13. ПОВНИЙ СИНТАКСИС ВЛАСТИВОСТІ
=====================================
Ім'я: Олександр, Вік: 30
```

**Пояснення:**
- Приватне поле `_name` зберігає значення (backing field)
- `get` повертає значення з поля
- `set` валідує значення перед збереженням (ім'я не може бути порожнім, вік 0-150)
- Якщо `person1.Age = 200`, викинеться `ArgumentException`

---

#### Приклад 14: Автоматичні властивості (PersonAutoProperty)
**Клас:** `PersonAutoProperty`  
**Що демонструє:** Автоматичні властивості без явного backing field

**Код:**
```csharp
PersonAutoProperty person2 = new PersonAutoProperty
{
    Name = "Марія",
    Age = 25,
    Email = "maria@example.com"
};
```

**Очікуваний вивід:**
```
14. АВТОМАТИЧНІ ВЛАСТИВОСТІ
=====================================
Ім'я: Марія, Вік: 25, Email: maria@example.com
```

**Пояснення:**
- Короткий синтаксис: `public string Name { get; set; }`
- Компілятор автоматично створює приватне поле
- Використовується ініціалізатор об'єкта `{ Name = "Марія" }`
- Немає валідації - значення зберігаються без перевірки

---

#### Приклад 15: Властивості з init (PersonInit)
**Клас:** `PersonInit`  
**Що демонструє:** Властивості з `init` аксесором (тільки при створенні)

**Код:**
```csharp
PersonInit person3 = new PersonInit
{
    Name = "Петро",
    Age = 28,
    Email = "petro@example.com"
};
// person3.Name = "Нове"; // Помилка!
```

**Очікуваний вивід:**
```
15. ВЛАСТИВОСТІ З INIT
=====================================
Ім'я: Петро, Вік: 28
Email: petro@example.com, Телефон: +380501234567
```

**Пояснення:**
- `init` дозволяє встановити значення тільки при створенні об'єкта
- Після створення змінити значення неможливо
- Корисно для незмінних (immutable) об'єктів
- Може мати валідацію в `init` аксесорі

---

#### Приклад 16: Обчислювані властивості (Rectangle)
**Клас:** `Rectangle`  
**Що демонструє:** Властивості, які обчислюють значення на льоту

**Код:**
```csharp
Rectangle rect = new Rectangle { Width = 5, Height = 10 };
Console.WriteLine($"Площа: {rect.Area}");
rect.Width = 5;
rect.Height = 5;
Console.WriteLine($"Чи є квадратом: {rect.IsSquare}");
```

**Очікуваний вивід:**
```
16. ОБЧИСЛЮВАНІ ВЛАСТИВОСТІ
=====================================
Прямокутник: ширина = 5, висота = 10
Площа: 50
Периметр: 30
Чи є квадратом: False

Після зміни: ширина = 5, висота = 5
Чи є квадратом: True
```

**Пояснення:**
- `Area` обчислюється як `Width * Height` при кожному зверненні
- `Perimeter` використовує короткий синтаксис `=>` (expression-bodied)
- `IsSquare` обчислює логічне значення на основі Width і Height
- Значення не зберігаються, обчислюються щоразу

---

#### Приклад 17: Ініціалізація автоматичних властивостей (PersonInitialized)
**Клас:** `PersonInitialized`  
**Що демонструє:** Автоматичні властивості з ініціалізацією за замовчуванням

**Код:**
```csharp
PersonInitialized person4 = new PersonInitialized();
Console.WriteLine($"За замовчуванням - Ім'я: {person4.Name}");
PersonInitialized person5 = new PersonInitialized { Name = "Анна" };
```

**Очікуваний вивід:**
```
17. ІНІЦІАЛІЗАЦІЯ АВТОМАТИЧНИХ ВЛАСТИВОСТЕЙ
=====================================
За замовчуванням - Ім'я: Unknown, Вік: 0
Активний: True, Створено: [поточна дата/час]
Після ініціалізації - Ім'я: Анна, Вік: 22
```

**Пояснення:**
- Властивості можна ініціалізувати при оголошенні: `{ get; set; } = "Unknown"`
- `CreatedAt` ініціалізується викликом методу: `= DateTime.Now`
- Якщо не вказати значення, використовується значення за замовчуванням

---

#### Приклад 18: Властивості з логікою (BankAccount)
**Клас:** `BankAccount`  
**Що демонструє:** Властивості з додатковою логікою в get/set

**Код:**
```csharp
BankAccount account = new BankAccount("ACC001", 1000);
Console.WriteLine($"Баланс: {account.Balance}");
account.Balance = 1500;
```

**Очікуваний вивід:**
```
18. ВЛАСТИВОСТІ З ЛОГІКОЮ В GET/SET
=====================================
Balance accessed: 1000
Баланс: 1000
Balance changed from 1000 to 1500
Новий баланс: 1500
```

**Пояснення:**
- `get` виводить повідомлення при доступі (логуювання)
- `set` виводить повідомлення про зміну та валідує значення
- Якщо `Balance = -100`, викинеться `ArgumentException`
- Демонструє можливість додавання логіки при доступі до властивості

---

#### Приклад 19: Властивості тільки для читання (PersonReadOnly)
**Клас:** `PersonReadOnly`  
**Що демонструє:** Властивості без `set` та обчислювані властивості

**Код:**
```csharp
PersonReadOnly person6 = new PersonReadOnly("ID001", "Сергій", new DateTime(1990, 5, 15));
Console.WriteLine($"ID: {person6.Id}");
Console.WriteLine($"Вік (обчислюваний): {person6.Age}");
```

**Очікуваний вивід:**
```
19. ВЛАСТИВОСТІ ТІЛЬКИ ДЛЯ ЧИТАННЯ
=====================================
ID: ID001
Ім'я: Сергій
Вік (обчислюваний): [поточний вік на основі дати народження]
```

**Пояснення:**
- `Id` має тільки `get`, значення встановлюється в конструкторі
- `Age` - обчислювана властивість, розраховує вік на основі дати народження
- Після створення об'єкта змінити значення неможливо
- Корисно для незмінних об'єктів

---

#### Приклад 20: Властивості з init та валідацією (Student)
**Клас:** `Student`  
**Що демонструє:** Комбінація `init` аксесора з валідацією

**Код:**
```csharp
Student student = new Student
{
    StudentId = "STU12345",
    Name = "Олена",
    Year = 2
};
```

**Очікуваний вивід:**
```
20. ВЛАСТИВОСТІ З INIT ТА ВАЛІДАЦІЄЮ
=====================================
Студент: Олена, ID: STU12345, Рік: 2
Активний: True
```

**Пояснення:**
- `StudentId` має `init` з валідацією: перевіряє, що не порожній і >= 5 символів
- Якщо `StudentId = "123"`, викинеться `ArgumentException`
- `IsActive` має значення за замовчуванням `true`
- Після створення змінити значення неможливо

---

## Швидкий довідник по виводу

### Перевантаження операторів
- **Унарні:** `-v1` → `(-3, -4)`
- **Бінарні:** `c1 + c2` → `3 + 7i`
- **Відношень:** `f1 == f2` → `True`
- **Логічні:** `b1 & b2` → `False`
- **Перетворення:** `Temperature t = 25.0` → `25°C`
- **Інкремент:** `++counter` → `6`

### Індексатори
- **Числовий:** `arr[0]` → `10`
- **Рядковий:** `dict["name"]` → `"Іван"`
- **Багатовимірний:** `matrix[0, 1]` → `2`
- **Тільки читання:** `readOnly[0]` → `"А"`

### Властивості
- **Повний синтаксис:** `person.Name = "Олександр"` → валідація
- **Автоматичні:** `person.Name { get; set; }` → без валідації
- **Init:** `person.Name { get; init; }` → тільки при створенні
- **Обчислювані:** `rect.Area` → обчислюється щоразу

## Технічні деталі

- Проект використовує .NET 10.0
- Увімкнено nullable reference types
- Всі приклади компілюються без попереджень
- Код написано з детальними коментарями українською мовою

