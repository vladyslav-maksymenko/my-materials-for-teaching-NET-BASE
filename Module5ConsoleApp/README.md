# Модуль 5. Перевантаження операторів. Індексатори і властивості

## 1. Перевантаження операторів

### 1.1 Вступ до перевантаження операторів

**Перевантаження операторів** - це можливість визначити власну поведінку для стандартних операторів C# (+, -, *, /, ==, !=, тощо) при роботі з об'єктами ваших класів.

**Навіщо це потрібно?**
- Зробити код більш читабельним і природним
- Дозволити використовувати стандартні оператори зі своїми типами
- Приклад: `vector1 + vector2` замість `vector1.Add(vector2)`

**Основні правила:**
- Перевантаження виконується через статичні методи з ключовим словом `operator`
- Можна перевантажувати тільки існуючі оператори, створювати нові не можна
- Не можна змінювати пріоритет операторів
- Не можна змінювати кількість операндів (унарний залишається унарним)

### 1.2 Перевантаження унарних операторів

**Унарні оператори** - це оператори, які працюють з одним операндом.

**Приклади унарних операторів:**
- `+` (плюс)
- `-` (мінус)
- `++` (інкремент)
- `--` (декремент)
- `!` (логічне заперечення)
- `~` (побітове заперечення)

**Синтаксис:**
```csharp
public static ReturnType operator operator_symbol(Type operand)
{
    // логіка
}
```

### 1.3 Перевантаження бінарних операторів

**Бінарні оператори** - це оператори, які працюють з двома операндами.

**Приклади бінарних операторів:**
- `+` (додавання)
- `-` (віднімання)
- `*` (множення)
- `/` (ділення)
- `%` (остача від ділення)

**Синтаксис:**
```csharp
public static ReturnType operator operator_symbol(Type1 operand1, Type2 operand2)
{
    // логіка
}
```

**Важливо:** Якщо перевантажуєте `+`, рекомендується також перевантажити `+=`.

### 1.4 Перевантаження операторів відношень

**Оператори відношень:**
- `==` (рівність)
- `!=` (нерівність)
- `<` (менше)
- `>` (більше)
- `<=` (менше або рівно)
- `>=` (більше або рівно)

**Важливе правило:** Якщо перевантажуєте `==`, обов'язково перевантажте `!=`. Аналогічно для `<` і `>`, `<=` і `>=`.

**Рекомендація:** При перевантаженні `==` і `!=` також перевизначте метод `Equals()` та `GetHashCode()` для коректної роботи з колекціями.

### 1.5 Перевантаження логічних операторів

**Логічні оператори:**
- `&` (логічне І)
- `|` (логічне АБО)
- `^` (виключне АБО)
- `&&` (умовне І)
- `||` (умовне АБО)

**Важливо:** Для `&&` і `||` потрібно також перевантажити `true` і `false` оператори.

### 1.6 Перевантаження операторів true і false

Оператори `true` і `false` використовуються для визначення "істинності" об'єкта в умовних виразах.

**Приклад використання:**
```csharp
MyClass obj = new MyClass();
if (obj) // використовує оператор true
{
    // код
}
```

**Синтаксис:**
```csharp
public static bool operator true(Type operand) { }
public static bool operator false(Type operand) { }
```

### 1.7 Перевантаження операторів перетворення

**Оператори перетворення** дозволяють конвертувати об'єкт одного типу в інший.

**Типи перетворень:**
- **Явне (explicit)** - потрібно вказувати тип: `(int)myObject`
- **Неявне (implicit)** - відбувається автоматично: `int x = myObject`

**Синтаксис:**
```csharp
// Неявне перетворення
public static implicit operator TargetType(SourceType source) { }

// Явне перетворення
public static explicit operator TargetType(SourceType source) { }
```

---

## 2. Індексатори

### 2.1 Поняття індексатора

**Індексатор** - це спеціальна властивість класу, яка дозволяє звертатися до об'єкта як до масиву, використовуючи квадратні дужки `[]`.

**Навіщо це потрібно?**
- Зробити доступ до даних більш інтуїтивним
- Приховати складну логіку доступу до даних
- Приклад: `myClass[0]` замість `myClass.GetValue(0)`

**Аналогія:** Індексатор - це як властивість, але з параметрами.

### 2.2 Створення одновимірних індексаторів

**Синтаксис:**
```csharp
public ReturnType this[IndexType index]
{
    get { /* логіка отримання */ }
    set { /* логіка встановлення */ }
}
```

**Приклад:**
```csharp
public string this[int index]
{
    get { return items[index]; }
    set { items[index] = value; }
}
```

### 2.3 Створення багатовимірних індексаторів

Індексатори можуть приймати кілька параметрів для роботи з багатовимірними структурами даних.

**Синтаксис:**
```csharp
public ReturnType this[Type1 index1, Type2 index2]
{
    get { /* логіка */ }
    set { /* логіка */ }
}
```

**Приклад:** Доступ до матриці: `matrix[2, 3]`

### 2.4 Перевантаження індексаторів

Можна створити кілька індексаторів з різними типами параметрів.

**Приклади:**
- `this[int index]` - доступ по числовому індексу
- `this[string key]` - доступ по рядковому ключу
- `this[int row, int col]` - доступ до матриці

---

## 3. Властивості

### 3.1 Що таке властивості

**Властивість (Property)** - це член класу, який надає гнучкий механізм для читання, запису або обчислення значення приватного поля.

**Переваги властивостей:**
- Інкапсуляція: контроль доступу до даних
- Валідація: можливість перевірки значень
- Обчислювані значення: можливість обчислювати значення на льоту
- Сумісність: можна змінювати реалізацію без зміни коду, що використовує властивість

### 3.2 Синтаксис оголошення властивостей

**Повний синтаксис:**
```csharp
private string name;

public string Name
{
    get { return name; }
    set { name = value; }
}
```

### 3.3 get, set, init

**get** - аксесор для читання значення
- Виконується при зверненні до властивості: `string x = obj.Name;`

**set** - аксесор для запису значення
- Виконується при присвоєнні: `obj.Name = "New Name";`
- `value` - ключове слово, яке містить значення, що присвоюється

**init** - аксесор для ініціалізації (тільки під час створення об'єкта)
- Доступний тільки в ініціалізаторах об'єктів
- Після створення об'єкта значення змінити не можна

**Приклад з init:**
```csharp
public string Name { get; init; }

// Можна при створенні
var obj = new MyClass { Name = "Test" };

// Не можна після створення
obj.Name = "New"; // Помилка!
```

### 3.4 Короткий синтаксис однорядкових властивостей

Якщо логіка get/set проста, можна використовувати короткий синтаксис:

```csharp
public string Name { get; set; }
```

Це еквівалентно повному синтаксису з приватним полем.

### 3.5 Приклади використання властивостей

**Властивість з валідацією:**
```csharp
private int age;

public int Age
{
    get { return age; }
    set 
    { 
        if (value < 0 || value > 150)
            throw new ArgumentException("Invalid age");
        age = value; 
    }
}
```

**Обчислювана властивість:**
```csharp
public string FullName
{
    get { return $"{FirstName} {LastName}"; }
}
```

**Властивість тільки для читання:**
```csharp
public string Id { get; private set; }
```

### 3.6 Автоматичні властивості (auto-property)

#### 3.6.1 Що таке автоматичні властивості

**Автоматична властивість** - це властивість, для якої компілятор автоматично створює приватне поле (backing field).

**Синтаксис:**
```csharp
public string Name { get; set; }
```

Компілятор автоматично створює:
- Приватне поле `_name` або `<Name>k__BackingField`
- Методи get і set для доступу до цього поля

#### 3.6.2 Приклади використання автоматичних властивостей

**Базова автоматична властивість:**
```csharp
public string Name { get; set; }
```

**Автоматична властивість тільки для читання:**
```csharp
public string Id { get; private set; }
```

**Автоматична властивість з init:**
```csharp
public string Name { get; init; }
```

#### 3.6.3 Ініціалізація автоматичних властивостей

**Ініціалізація при оголошенні:**
```csharp
public string Name { get; set; } = "Default Name";
public int Count { get; set; } = 0;
```

**Ініціалізація в конструкторі:**
```csharp
public class MyClass
{
    public string Name { get; set; }
    
    public MyClass()
    {
        Name = "Initial Value";
    }
}
```

**Ініціалізація через ініціалізатор об'єкта:**
```csharp
var obj = new MyClass 
{ 
    Name = "Test",
    Count = 10
};
```

---

## Практичні рекомендації

### Перевантаження операторів:
- ✅ Використовуйте для типів, які природно підтримують операції (вектори, матриці, комплексні числа)
- ❌ Не перевантажуйте оператори для типів, де це неочевидно
- ✅ Завжди перевантажуйте пари операторів разом (== і !=, < і >)
- ✅ Перевизначайте Equals() і GetHashCode() при перевантаженні ==

### Індексатори:
- ✅ Використовуйте для класів, які представляють колекції або контейнери
- ✅ Додавайте валідацію індексів
- ✅ Використовуйте різні типи індексів для різних способів доступу

### Властивості:
- ✅ Використовуйте властивості замість публічних полів
- ✅ Додавайте валідацію в set аксесори
- ✅ Використовуйте автоматичні властивості, коли логіка проста
- ✅ Використовуйте init для незмінних після створення значень

