# Модуль 7. Інтерфейси в C#

## 1. Поняття інтерфейсу

**Інтерфейс** - це контракт, який визначає набір методів, властивостей, подій та індексаторів, які повинна реалізувати клас або структура. Інтерфейс не містить реалізації - він лише описує, що має бути реалізовано.

### Основні характеристики інтерфейсів:
- Інтерфейс не може містити поля (лише властивості)
- Всі члени інтерфейсу за замовчуванням є `public` та `abstract`
- Клас може реалізувати кілька інтерфейсів одночасно
- Інтерфейси підтримують успадкування (один інтерфейс може успадковувати інші)
- Інтерфейси не можуть містити конструкторів
- Інтерфейси не можуть містити статичних членів (до C# 8.0)

## 2. Синтаксис оголошення інтерфейсів

### Базовий синтаксис:
```csharp
interface IInterfaceName
{
    // Оголошення методів
    void MethodName();
    int Calculate(int x, int y);
    
    // Оголошення властивостей
    string Name { get; set; }
    int Count { get; }
    
    // Оголошення подій
    event EventHandler SomethingHappened;
    
    // Оголошення індексаторів
    int this[int index] { get; set; }
}
```

### Правила іменування:
- Ім'я інтерфейсу зазвичай починається з великої літери `I`
- Наприклад: `IComparable`, `IDisposable`, `IEnumerable`

## 3. Приклади створення інтерфейсів

### Простий інтерфейс:
```csharp
interface IFlyable
{
    void Fly();
    double MaxSpeed { get; }
}
```

### Інтерфейс з кількома методами:
```csharp
interface IShape
{
    double CalculateArea();
    double CalculatePerimeter();
    void Draw();
}
```

## 4. Інтерфейсні посилання

**Інтерфейсне посилання** - це змінна типу інтерфейсу, яка може посилатися на об'єкт будь-якого класу, що реалізує цей інтерфейс.

### Переваги:
- Поліморфізм: можна працювати з різними класами через один інтерфейс
- Слабке зв'язування: код залежить від інтерфейсу, а не від конкретного класу
- Гнучкість: легко замінювати реалізації

### Приклад:
```csharp
IFlyable flyable = new Bird();  // Інтерфейсне посилання
flyable.Fly();
```

## 5. Інтерфейсні індексатори та властивості

### Властивості в інтерфейсах:
Інтерфейси можуть містити властивості з автоматичною реалізацією або з явною реалізацією в класі:

```csharp
interface IPerson
{
    string Name { get; set; }
    int Age { get; }
}
```

### Індексатори в інтерфейсах:
```csharp
interface IList
{
    int this[int index] { get; set; }
    int Count { get; }
}
```

## 6. Успадкування інтерфейсів

Інтерфейси можуть успадковувати інші інтерфейси. Це дозволяє створювати ієрархії інтерфейсів.

### Приклад:
```csharp
interface IAnimal
{
    void Eat();
}

interface IFlyable
{
    void Fly();
}

interface IBird : IAnimal, IFlyable
{
    void Chirp();
}
```

Клас, що реалізує `IBird`, повинен реалізувати всі методи з `IAnimal`, `IFlyable` та `IBird`.

## 7. Проблеми приховування імен при успадкуванні інтерфейсів

### Проблема:
Коли два інтерфейси мають методи з однаковими іменами та сигнатурами, виникає конфлікт імен.

### Рішення 1: Явна реалізація інтерфейсу
```csharp
interface IFirst
{
    void DoSomething();
}

interface ISecond
{
    void DoSomething();
}

class MyClass : IFirst, ISecond
{
    // Явна реалізація для IFirst
    void IFirst.DoSomething() { }
    
    // Явна реалізація для ISecond
    void ISecond.DoSomething() { }
}
```

### Рішення 2: Загальна реалізація
Якщо методи мають однакову логіку, можна реалізувати один метод, який буде використовуватися обома інтерфейсами.

## 8. Аналіз стандартних інтерфейсів

### IComparable<T>
Використовується для порівняння об'єктів:
```csharp
interface IComparable<T>
{
    int CompareTo(T other);
}
```

### IEnumerable<T>
Дозволяє перебирати колекцію:
```csharp
interface IEnumerable<T> : IEnumerable
{
    IEnumerator<T> GetEnumerator();
}
```

### IDisposable
Для звільнення некерованих ресурсів:
```csharp
interface IDisposable
{
    void Dispose();
}
```

### ICloneable
Для створення копій об'єктів:
```csharp
interface ICloneable
{
    object Clone();
}
```

### IEquatable<T>
Для визначення рівності об'єктів:
```csharp
interface IEquatable<T>
{
    bool Equals(T other);
}
```

## Переваги використання інтерфейсів

1. **Поліморфізм**: Один інтерфейс, багато реалізацій
2. **Тестування**: Легко створювати моки та заглушки
3. **Розширюваність**: Легко додавати нові реалізації
4. **Розділення відповідальності**: Чітке визначення контрактів
5. **Слабке зв'язування**: Код залежить від абстракцій, а не від конкретних класів

## Відмінності між інтерфейсами та абстрактними класами

| Характеристика | Інтерфейс | Абстрактний клас |
|----------------|-----------|------------------|
| Наслідування | Множинне | Одиничне |
| Поля | Ні (лише властивості) | Так |
| Конструктори | Ні | Так |
| Реалізація методів | Ні (до C# 8.0) | Так (часткова) |
| Модифікатори доступу | Public | Різні |
| Статичні члени | Ні (до C# 8.0) | Так |

## Практичні рекомендації

1. Використовуйте інтерфейси для визначення контрактів
2. Назви інтерфейсів починайте з `I`
3. Інтерфейси мають бути невеликими та зосередженими на одній відповідальності
4. Використовуйте явну реалізацію для вирішення конфліктів імен
5. Виберіть інтерфейс, якщо потрібне множинне наслідування
6. Виберіть абстрактний клас, якщо потрібна спільна реалізація для похідних класів

