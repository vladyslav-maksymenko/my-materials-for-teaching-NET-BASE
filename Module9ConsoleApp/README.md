# Модуль 9. Вступ до Generics, Ітераторів та Колекцій

## Generics (Узагальнення)

### Що таке Generics?

**Generics** (узагальнення) - це механізм мови C#, який дозволяє створювати класи, інтерфейси, методи та делегати, що працюють з типами, визначеними під час використання, а не під час написання коду.

**Синтаксис:** `ClassName<T>` де `T` - це параметр типу (type parameter).

### Необхідність використання Generics

**Проблеми без Generics:**
1. **Втрата типобезпеки** - використання `object` потребує приведення типів
2. **Потенційні помилки під час виконання** - неправильне приведення типів
3. **Погіршення продуктивності** - boxing/unboxing для value types
4. **Дублювання коду** - створення окремих класів для кожного типу

**Переваги Generics:**
- ✅ **Типобезпека** - помилки виявляються під час компіляції
- ✅ **Покращена продуктивність** - немає boxing/unboxing
- ✅ **Повторне використання коду** - один клас для різних типів
- ✅ **Краща читабельність** - код стає більш зрозумілим

### Створення Generic-класів

```csharp
public class Box<T>
{
    private T item;
    
    public void SetItem(T item) { this.item = item; }
    public T GetItem() { return item; }
}
```

### Типи, вкладені всередину Generic-класу

Вкладені класи можуть використовувати параметри типу зовнішнього класу:

```csharp
public class Container<T>
{
    public class NestedClass<U>
    {
        // Може використовувати як T, так і U
    }
}
```

### Використання обмежень (Constraints)

Обмеження дозволяють вказати вимоги до параметрів типів:

- `where T : class` - T має бути reference типом
- `where T : struct` - T має бути value типом
- `where T : new()` - T має мати конструктор без параметрів
- `where T : BaseClass` - T має наслідуватися від BaseClass
- `where T : IInterface` - T має реалізувати IInterface
- `where T : U` - T має наслідуватися від U

**Приклад:**
```csharp
public class Repository<T> where T : class, IEntity, new()
{
    // T має бути класом, реалізувати IEntity та мати конструктор без параметрів
}
```

### Створення Generic-інтерфейсів

```csharp
public interface IRepository<T>
{
    void Add(T item);
    T GetById(int id);
    IEnumerable<T> GetAll();
}
```

### Створення Generic-делегатів

```csharp
public delegate T Transformer<T>(T input);
public delegate TResult Func<T, TResult>(T arg);
```

### Створення Generic-методів

```csharp
public static T Max<T>(T a, T b) where T : IComparable<T>
{
    return a.CompareTo(b) > 0 ? a : b;
}
```

---

## Ітератори (Iterators)

### Що таке ітератор?

**Ітератор** - це метод, властивість або індексатор, який повертає послідовність значень за допомогою ключового слова `yield return`.

### Синтаксис і приклади використання ітераторів

**Основні ключові слова:**
- `yield return` - повертає наступне значення
- `yield break` - завершує ітерацію

**Приклад:**
```csharp
public IEnumerable<int> GetNumbers()
{
    for (int i = 0; i < 10; i++)
    {
        yield return i;
    }
}
```

**Використання:**
```csharp
foreach (var number in GetNumbers())
{
    Console.WriteLine(number);
}
```

**Переваги:**
- Ліниве виконання (lazy evaluation)
- Ефективне використання пам'яті
- Простий синтаксис

---

## Колекції (Collections)

### Поняття колекції

**Колекція** - це структура даних, яка призначена для зберігання та управління групою об'єктів.

### Generic-колекції

Generic-колекції забезпечують типобезпеку та кращу продуктивність порівняно з не-generic колекціями.

### Класи колекцій

#### 1. List<T>
Динамічний масив, що дозволяє додавати, видаляти та змінювати елементи.

**Основні методи:**
- `Add(T item)` - додає елемент
- `Remove(T item)` - видаляє елемент
- `Contains(T item)` - перевіряє наявність
- `Count` - кількість елементів

#### 2. Dictionary<TKey, TValue>
Колекція ключ-значення для швидкого пошуку за ключем.

**Основні методи:**
- `Add(TKey key, TValue value)` - додає пару
- `ContainsKey(TKey key)` - перевіряє наявність ключа
- `TryGetValue(TKey key, out TValue value)` - безпечне отримання значення

#### 3. Stack<T>
Колекція типу LIFO (Last In, First Out) - останній прийшов, перший вийшов.

**Основні методи:**
- `Push(T item)` - додає на вершину
- `Pop()` - видаляє з вершини
- `Peek()` - переглядає вершину без видалення

#### 4. Queue<T>
Колекція типу FIFO (First In, First Out) - перший прийшов, перший вийшов.

**Основні методи:**
- `Enqueue(T item)` - додає в кінець
- `Dequeue()` - видаляє з початку
- `Peek()` - переглядає початок без видалення

#### 5. SortedList<TKey, TValue>
Автоматично відсортований словник за ключами.

#### 6. HashSet<T>
Колекція унікальних елементів без дублікатів.

#### 7. LinkedList<T>
Двозв'язний список для ефективного додавання/видалення в будь-якому місці.

### Інтерфейси колекцій

#### IList<T>
Інтерфейс для списків з індексацією:
- `this[int index]` - індексатор
- `Insert(int index, T item)` - вставка
- `RemoveAt(int index)` - видалення за індексом

#### IEnumerable<T>
Інтерфейс для перебору елементів:
- `GetEnumerator()` - повертає ітератор

#### IEnumerator<T>
Інтерфейс ітератора:
- `Current` - поточний елемент
- `MoveNext()` - перехід до наступного
- `Reset()` - скидання

#### ICollection<T>
Базовий інтерфейс колекцій:
- `Count` - кількість елементів
- `Add(T item)`, `Remove(T item)`, `Clear()`, `Contains(T item)`

#### IDictionary<TKey, TValue>
Інтерфейс словників:
- `Keys` - колекція ключів
- `Values` - колекція значень
- `this[TKey key]` - індексатор за ключем

#### IComparer<T>
Інтерфейс для порівняння об'єктів:
- `Compare(T x, T y)` - порівняння двох об'єктів

### Приклади використання

Дивіться детальні приклади в файлах коду з коментарями та поясненнями.

---

## Структура проєкту

- `Program.cs` - головний файл з демонстрацією всіх концепцій
- `GenericExamples.cs` - приклади Generic-класів, інтерфейсів, делегатів та методів
- `IteratorExamples.cs` - приклади ітераторів
- `CollectionExamples.cs` - приклади роботи з колекціями

---

## Як запустити

```bash
dotnet build
dotnet run
```

