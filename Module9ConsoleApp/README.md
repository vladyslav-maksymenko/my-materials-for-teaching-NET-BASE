# Модуль 9. Вступ до Generics, Ітераторів та Колекцій

## Generics (Узагальнення)

### Що таке Generics?

**Generics** (узагальнення) - це потужний механізм у C# (починаючи з .NET Framework 2.0), який дозволяє створювати елементи (класи, інтерфейси, методи, делегати), що працюють з типами, визначеними користувачем під час використання, а не під час написання коду. Це також відомо як `параметризований` тип або `типізований об'єкт`.

**Синтаксис:** `ClassName<T>` де `T` - це параметр типу (type parameter), який буде замінено конкретним типом під час компіляції/виконання.

Узагальнені типи дуже легко розпізнати. Вони вирізняються наявністю кутових дужок `<>` після назви типу, усередині яких зазначається певний тип або типи даних.

### Необхідність та Переваги Generics
Введення Generics було спровоковано проблемами, що виникають під час роботи з неузагальненими колекціями, такими як `ArrayList`, які зберігають елементи типу `object`. 

Можна розцінювати як етап еволюції мови C#, спровокований двома важливими проблемами, що виникають під час роботи з неузагальненими колекціями - низька продуктивність і безпека типів.

Проблема безпеки типів пов'язана з універсальністю неузагальнених колекцій - зберігання даних типу object. Така гнучкість у деяких випадках зручна, коли в колекцію необхідно помістити змінні будь-якого типу. Однак, під час вилучення даних із колекції необхідно здійснювати явне приведення типу. Водночас можна легко припуститися помилки приведення, яка виявиться тільки на етапі виконання програми. Тому робота з неузагальненими колекціями повинна супроводжуватися написанням додаткового коду перевірок і приведення — блок try-catch або оператори is чи as

```csharp
class Program
    {
        static void Main(string[] args)
        {
            ArrayList arrayList = new ArrayList();
            // поміщаємо в колекцію елементи типу int
            arrayList.Add(10);
            try
            {
                // під час вилучення виконуємо приведення до типу short
                // через помилкове зазначення типу виникає виняток
                short a = (short)arrayList[0];
            }
            catch (InvalidCastException e)
            {
                WriteLine(e.Message);
            }
        }
    }
```
| Проблема без Generics | Перевага Generics |
| :--- | :--- |
| **Втрата типобезпеки** та помилки під час виконання (явне приведення типів). | ✅ **Типобезпека**. Помилки виявляються на етапі компіляції. |
| **Низька продуктивність** через Boxing (пакування) та Unboxing (розпакування) для значущих типів. | ✅ **Покращена продуктивність.** Усунення boxing/unboxing для значущих типів. |
| **Дублювання коду** (необхідність створювати окремі класи/методи для кожного типу). | ✅ **Повторне використання коду.** Один клас/метод для різних типів. |
| Складніший, менш зрозумілий код. | ✅ **Краща читабельність** та лаконічність. |

    Наприклад, до Generics, якщо ви зберігали цілі числа в ArrayList, компілятор не знав, що там цілі числа, і міг дозволити додати рядок. Generics дозволяють створити List<int>, де гарантовано будуть лише цілі числа.

### Механізм Boxing (Пакування) та Unboxing (Розпакування)

Це ключовий аспект, що пояснює перевагу Generics у продуктивності.

Пакування (Boxing): Перетворення значущого типу (наприклад, int) на посилальний тип (object). Це відбувається, коли значущий тип зберігається в колекції, яка очікує object. Це вимагає виділення пам'яті в купі (Heap) та копіювання значення.

Розпакування (Unboxing): Зворотне перетворення посилального типу на значущий тип. Потрібне явне приведення типів.

```csharp
class Program
    {
        static void Main(string[] args)
        {
            object obj = 45; // boxing
            WriteLine($"Пакування: {obj}");

            int number = (int)obj; // unboxing(необхідність здійснення явного приведення типів, інакше згенерується помилка на етапі компіляції)
            WriteLine($"Розпакування: {number}");
        }
    }
```
Розглянемо код нижче:
```csharp
 class Program
    {
        static void Main(string[] args)
        {
            ArrayList arrayList = new ArrayList();
            // під час запису елемента в колекцію тип int приводиться в object - ПАКУВАННЯ
            arrayList.Add(10);
            arrayList.Add(12);

            // під час вилучення виконуємо приведення типу - РОЗПАКУВАННЯ
            int a = (int)arrayList[0];
            // виведення значення - int приводиться до string - ПАКУВАННЯ
            Write($"Перший елемент колекції: {a}");

            WriteLine("\n\nВсі елементи колекції:");
            foreach (int item in arrayList)
            {
                WriteLine($"\t{item}"); // ПАКУВАННЯ
            }
        }
    }
```
Коли ви використовуєте `List<int>` замість `ArrayList`, пакування/розпакування не відбувається, що значно підвищує продуктивність і зменшує навантаження на збирач сміття (GC).

### Порівняння Generic's та Неузагальнених Колекцій
З появою концепції Generics у FCL (Framework Class Library), практично для всіх класів неузагальнених колекцій з'явилися відповідні їм узагальнені аналоги.

Місце розташування: Ці узагальнені колекції, а також узагальнені інтерфейси, знаходяться в просторі імен `System.Collections.Generic`.

| Generic-колекції (`System.Collections.Generic`) | Неузагальнені колекції (`System.Collections`) |
| :--- | :--- |
| `List<T>` | `ArrayList` |
| `Dictionary<TKey, TValue>` | `Hashtable` (Хеш-таблиця) |
| `SortedList<TKey, TValue>` | `SortedList` |
| `Stack<T>` | `Stack` |
| `Queue<T>` | `Queue` |

Головна відмінність generic-колекцій від неузагальнених колекцій (крім назв, що не завжди збігаються) полягає в тому, що замість типу даних object у generic-колекціях використовується узагальнений параметр типу, який зазначено в кутових дужках після назви колекції. У результаті ті методи і властивості, які в неузагальненій колекції використовували тип даних object, у generic-колекції використовують конкретний тип даних.
```csharp
 class Program
    {
        static void Main(string[] args)
        {
            List<int> listInt = new List<int> { 53, 12, 78 };
            listInt.Add(8.9); //Помилка: не можна конвертувати тип double в int
        }
    }
```
Для порівняння часових витрат при зберіганні структурних типів у неузагальненій та узагальненій колекції ми наведемо приклад, запропонований Jeffrey Richter у книзі "The CLR via C#".

<details>
<summary>Показати/Приховати Код Тестування Продуктивності (Generics vs ArrayList)</summary>

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using static System.Console;

namespace SimpleProject
{
    /// <summary>
    /// Допоміжний клас для профілювання ділянки коду
    /// виконує вимірювання часу виконання
    /// і підрахунок кількості збирань сміття
    /// </summary>
    internal sealed class OperationTimer : IDisposable
    {
        long _startTime;
        string _text;
        int _collectionCount;

        public OperationTimer(string text)
        {
            PrepareForOperation();
            _text = text;

            // зберігається кількість збирань сміття, виконаних на поточний момент
            _collectionCount = GC.CollectionCount(0);

            // зберігається початковий час
            _startTime = Stopwatch.GetTimestamp();
        }

        /// <summary>
        /// Викликається в разі руйнування об'єкта
        /// Виводить:
        /// значення часу, що минув з моменту створення об'єкта 
        /// до моменту його видалення
        /// кількість виконаних збирань сміття, виконаних за цей час
        /// </summary>

        public void Dispose()
        {
            WriteLine($"{_text}\t{(Stopwatch.GetTimestamp() - _startTime) / (double)Stopwatch.Frequency:0.00} секунди (збирань сміття {GC.CollectionCount(0) - _collectionCount})");
        }
        /// <summary>
        /// Метод видаляються всі невикористовувані об'єкти
        /// Це потрібно для "чистоти експерименту",
        /// тобто, щоб збирання сміття відбувалося тільки для об'єктів,
        /// які створюватимуться в профільованому блоці коду
        /// </summary>
        private static void PrepareForOperation()
        {
            GC.Collect();
            GC.WaitForPendingFinalizers();
            GC.Collect();
        }
    }
    class Program
    {
        /// <summary>
        /// метод для тестування продуктивності
        /// узагальненого і неузагальненого списку
        /// </summary>
        private static void ValueTypePerfTest()
        {
            const int COUNT = 10000000;
            // об'єкт OperationTimer 
            // створюється перед початком використання колекції
            // після завершення її використання 
            // виводить час, витрачений на роботу з колекцією  
            using (new OperationTimer("List"))
            {
                // використання узагальненого списку
                List<int> list = new List<int>(COUNT);
                for (int n = 0; n < COUNT; n++)
                {
                    list.Add(n);
                    int x = list[n];
                }
                list = null; // для гарантованого виконання збирання сміття
            }

            using (new OperationTimer("ArrayList"))
            {
                // використання неузагальненого списку
                ArrayList array = new ArrayList();
                for (int n = 0; n < COUNT; n++)
                {
                    array.Add(n); // виконується пакування
                    int x = (int)array[n]; // виконується розпакування
                }
                array = null; // для гарантованого виконання збирання сміття
            }
        }
        static void Main(string[] args)
        {
            ValueTypePerfTest();
        }
    }
}

</details>



### Створення Generic-класів

```csharp
public class Box<T>
{
    private T item;
    
    public void SetItem(T item) { this.item = item; }
    public T GetItem() { return item; }
}
```

### Типи, вкладені всередину Generic-класу

Вкладені класи можуть використовувати параметри типу зовнішнього класу:

```csharp
public class Container<T>
{
    public class NestedClass<U>
    {
        // Може використовувати як T, так і U
    }
}
```

### Використання обмежень (Constraints)

Обмеження дозволяють вказати вимоги до параметрів типів:

- `where T : class` - T має бути reference типом
- `where T : struct` - T має бути value типом
- `where T : new()` - T має мати конструктор без параметрів
- `where T : BaseClass` - T має наслідуватися від BaseClass
- `where T : IInterface` - T має реалізувати IInterface
- `where T : U` - T має наслідуватися від U

**Приклад:**
```csharp
public class Repository<T> where T : class, IEntity, new()
{
    // T має бути класом, реалізувати IEntity та мати конструктор без параметрів
}
```

### Створення Generic-інтерфейсів

```csharp
public interface IRepository<T>
{
    void Add(T item);
    T GetById(int id);
    IEnumerable<T> GetAll();
}
```

### Створення Generic-делегатів

```csharp
public delegate T Transformer<T>(T input);
public delegate TResult Func<T, TResult>(T arg);
```

### Створення Generic-методів

```csharp
public static T Max<T>(T a, T b) where T : IComparable<T>
{
    return a.CompareTo(b) > 0 ? a : b;
}
```

---

## Ітератори (Iterators)

### Що таке ітератор?

**Ітератор** - це метод, властивість або індексатор, який повертає послідовність значень за допомогою ключового слова `yield return`.

### Синтаксис і приклади використання ітераторів

**Основні ключові слова:**
- `yield return` - повертає наступне значення
- `yield break` - завершує ітерацію

**Приклад:**
```csharp
public IEnumerable<int> GetNumbers()
{
    for (int i = 0; i < 10; i++)
    {
        yield return i;
    }
}
```

**Використання:**
```csharp
foreach (var number in GetNumbers())
{
    Console.WriteLine(number);
}
```

**Переваги:**
- Ліниве виконання (lazy evaluation)
- Ефективне використання пам'яті
- Простий синтаксис

---

## Колекції (Collections)

### Поняття колекції

**Колекція** - це структура даних, яка призначена для зберігання та управління групою об'єктів.

### Generic-колекції

Generic-колекції забезпечують типобезпеку та кращу продуктивність порівняно з не-generic колекціями.

### Класи колекцій

#### 1. List<T>
Динамічний масив, що дозволяє додавати, видаляти та змінювати елементи.

**Основні методи:**
- `Add(T item)` - додає елемент
- `Remove(T item)` - видаляє елемент
- `Contains(T item)` - перевіряє наявність
- `Count` - кількість елементів

#### 2. Dictionary<TKey, TValue>
Колекція ключ-значення для швидкого пошуку за ключем.

**Основні методи:**
- `Add(TKey key, TValue value)` - додає пару
- `ContainsKey(TKey key)` - перевіряє наявність ключа
- `TryGetValue(TKey key, out TValue value)` - безпечне отримання значення

#### 3. Stack<T>
Колекція типу LIFO (Last In, First Out) - останній прийшов, перший вийшов.

**Основні методи:**
- `Push(T item)` - додає на вершину
- `Pop()` - видаляє з вершини
- `Peek()` - переглядає вершину без видалення

#### 4. Queue<T>
Колекція типу FIFO (First In, First Out) - перший прийшов, перший вийшов.

**Основні методи:**
- `Enqueue(T item)` - додає в кінець
- `Dequeue()` - видаляє з початку
- `Peek()` - переглядає початок без видалення

#### 5. SortedList<TKey, TValue>
Автоматично відсортований словник за ключами.

#### 6. HashSet<T>
Колекція унікальних елементів без дублікатів.

#### 7. LinkedList<T>
Двозв'язний список для ефективного додавання/видалення в будь-якому місці.

### Інтерфейси колекцій

#### IList<T>
Інтерфейс для списків з індексацією:
- `this[int index]` - індексатор
- `Insert(int index, T item)` - вставка
- `RemoveAt(int index)` - видалення за індексом

#### IEnumerable<T>
Інтерфейс для перебору елементів:
- `GetEnumerator()` - повертає ітератор

#### IEnumerator<T>
Інтерфейс ітератора:
- `Current` - поточний елемент
- `MoveNext()` - перехід до наступного
- `Reset()` - скидання

#### ICollection<T>
Базовий інтерфейс колекцій:
- `Count` - кількість елементів
- `Add(T item)`, `Remove(T item)`, `Clear()`, `Contains(T item)`

#### IDictionary<TKey, TValue>
Інтерфейс словників:
- `Keys` - колекція ключів
- `Values` - колекція значень
- `this[TKey key]` - індексатор за ключем

#### IComparer<T>
Інтерфейс для порівняння об'єктів:
- `Compare(T x, T y)` - порівняння двох об'єктів

### Приклади використання

Дивіться детальні приклади в файлах коду з коментарями та поясненнями.

---

## Структура проєкту

- `Program.cs` - головний файл з демонстрацією всіх концепцій
- `GenericExamples.cs` - приклади Generic-класів, інтерфейсів, делегатів та методів
- `IteratorExamples.cs` - приклади ітераторів
- `CollectionExamples.cs` - приклади роботи з колекціями

---

## Як запустити

```bash
dotnet build
dotnet run
```

